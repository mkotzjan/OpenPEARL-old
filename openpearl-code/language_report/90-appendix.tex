\chapter{Appendix}

\section{Data Types and their usability}    % A1

The following overview shows for each of the available data types, whether
objects of this type may

\begin{itemize}
\item be summarised to arrays,
\item occur as structure components,
\item be formal procedure parameters,
\item be results of a function procedure,
\item be values of a reference variable,
\item be transmitted to or from data stations,
\item be provided with allocation protection,
\item be global, or
\item be provided with the initialisation attribute.
\end{itemize}

\begin{table}[htb]
\begin{tabular}{lccccccccc}
{\bf type}     & \multicolumn{9}{c}{{\bf usage}} \\ 
               & array & struct. & para- & result & ref.  & dation & INV & GLOBAL & INIT \\ 
               &       &         & meter & type   & value & class  &     &        &      \\ \hline
FIXED          & x     &  x      & x     &  x     &  x    &   x    &  x  &    x   &  x   \\
FLOAT          & x     &  x      & x     &  x     &  x    &   x    &  x  &    x   &  x   \\
BIT            & x     &  x      & x     &  x     &  x    &   x    &  x  &    x   &  x   \\
CHAR           & x     &  x      & x     &  x     &  x    &   x    &  x  &    x   &  x   \\
CLOCK          & x     &  x      & x     &  x     &  x    &   x    &  x  &    x   &  x   \\
DUR            & x     &  x      & x     &  x     &  x    &   x    &  x  &    x   &  x   \\
SEMA           & x     &  --     & x     &  --    &  x    &   --   &  -- &    x   &  --  \\
BOLT           & x     &  --     & x     &  --    &  x    &   --   &  -- &    x   &  --  \\
IRPT           & x     &  --     & x     &  --    &  x    &   --   &  -- &    x   &  --  \\
SIGNAL         & x     &  --     & x     &  --    &  x    &   --   &  -- &    x   &  --  \\
DATION         & x     &  --     & x     &  --    &  x    &   --   &  -- &    x   &  --  \\
array          & --    &  x      & x     &  --    &  x    &   --   &  x  &    x   &  x   \\
STRUCT         & x     &  x      & x     &  x     &  x    &   x    &  x  &    x   &  x   \\
new type       & x     &  x      & x     &  x     &  x    &   x    &  x  &    x   &  x   \\
REF            & x     &  x      & x     &  x     &  --   &   --   &  x  &    x   &  x   \\
procedure      & --    &  --     & --    &  --    &  x    &   --   &  -- &    x   &  --  \\
TASK           & --    &  --     & --    &  --    &  x    &   --   &  -- &    x   &  --  \\
FORMAT         & --    &  --     & --    &  --    &  --   &   --   &  -- &    --  &  --  \\
REF CHAR ( )   & x     &  x      & x     &  --    &  --   &   --   &  x  &    x   &  x   \\
REF PROC       & x     &  x      & x     &  --    &  --   &   --   &  x  &    x   &  x   \\
REF TASK       & x     &  x      & x     &  x     &  --   &   --   &  x  &    x   &  x   \\
REF STRUCT [ ] & x     &  x      & x     &  x     &  --   &   --   &  x  &    x   &  x   \\
\end{tabular}
\end{table}
                                                                                 
Objects of type SEMA, BOLT, IRPT, SIGNAL, DATION or array may only be 
passed on by means of identification (IDENT) as procedure parameters.

\newpage
\section{Predefined Functions}   % A 2

This appendix describes the functions known to the PEARL compiler. They
can be used in the single modules without specifying them before. If one
of the functions is specified in a module, no object may exist with the
functions' name at module level.

\begin{tobedone}
\subsection{The Function NOW}    % A 2.1

The function procedure NOW passes back the actual time or system time, resp., 
as value of type CLOCK. A specification of the function looks like this:\\

{\bf SPC} NOW {\bf PROC RETURNS ( CLOCK ) GLOBAL} ; 


\subsection{The Function DATE}    % A 2.2

The actual date can be received by invoking the function procedure DATE.
The function result is a character string constant of length 10, containing
the date in the form ``year--month--day''. Here an example for December 5,
1991: ``1991--12-05''. The function can be specified like this:\\

{\bf SPC} DATE {\bf PROC RETURNS ( CHAR(10) ) GLOBAL} ;
\end{tobedone}

\begin{added}
\section{CPP-Insertions}
The language translation is done in two steps.
Step 1 translates PEARL into C++.
Step 2 translates C++ into the plattform specific machine code.

It is possible to insert C++ statements into the generated C++ 
code. The position of the insertion is
\begin{itemize}
\item in system part: {\em not defined yet}
\item on module level in the problem part 
   it is not clearly defined, since the first compilation
   steps adds some information for administration is between.
\item in tasks and procedures just between the output of the surrounding
generated output
\end{itemize}

The syntax is.

CPP\_insertion ::=\\
\x {\bf \_\_cpp\_\_} ( CharacterStringConstant ... );

The CharacterStringConstants are expected in PEARL notation.
Some characters must be marked with the switch symbol as shown in the table
below:

\begin{tabular}{l|l}
C & PEARL \\
\hline
\verb|\| & \verb|\\| \\
\verb|'| & \verb|\'|  \\
\end{tabular}
\end{added}

\newpage
\section{Syntax}    % A 3

Following meta characters are used in the syntax description:\\ 

\begin{tabular}{ll}
meta character & meaning \\ \hline
::=            & introduction of a Name (nonterminal symbol) for a language form\\
$[\ ]$         & bracketing of optional parts of a language form \\ 
$\mid$         & separation of alternative parts of a language form\\
\{ \}          & putting together several elements to a new element\\
$^{...}$       & one or multiple repetition of the preceding element\\
               & (or of several elements bracketed by \{ \} or [ ] ) \\
$\S $          & separates an explaining comment from a language form Name\\
$/^*$ $^*/$    & comment brackets: 
                 includes an explaining text, possibly explaining the\\
               & language form in detail instead of a formal description\\
\end{tabular}

All other elements occurring in the syntax rules are either Names of language
forms or terminal symbols. Examples for terminal symbols are the PEARL
keywords (printed boldly) or the characters semicolon ``;'', opening round
bracket ``('' and closing round bracket ``)'', 
% Klammer auf und zu ???
or the apostrophe `` ' ''; the terminal symbols opening square bracket ``[''
and closing square bracket ``]'' are printed boldly to distinguish them
from the meta symbols for optional parts. Attention: the round brackets are
no meta characters and have thus no grouping effect!\\

The symbol PEARL-Program is the initial symbol of the following syntax
description.

\subsection{Program}    % A 3.1

PEARL-Program ::=\\
\x Module $^{...}$\\

Module ::=\\
\x {\bf MODULE} [ [ ( ] Identifier$\S $OfTheModule [ ) ] ] ;\\
\x \{ SystemPart [ ProblemPart ] $\mid$ ProblemPart \} \\
\x {\bf MODEND} ;

\subsection{System Part}   % A 3.2

SystemPart ::= \\
\x {\bf SYSTEM} ;\\
\x \x [ UserNameDeclaration$\S $ForDationInterruptOrSignal ] $^{...}$\\

UserNameDeclaration ::=\\
\x Identifier$\S $UserName: Identifier$\S $SystemName [ ( nngz$\S $Index ) ]\\
\x \x [ $^*$ nngz$\S $Channel [ $^*$ nngz$\S $Position [ , nngz$\S $Width ] ] ];\\
\x $\mid$ Identifier$\S $UserName: Identifier$\S $SIGNAL-SystemName\\
\x \x [ ( Identifier$\S $ErrorNumber [ , Identifier$\S $ErrorNumber ] $^{...}$ ) ] ;\\

nngz ::= \\
\x IntegerWithoutPrecision$\S $NonNegative

\subsection{Basic Elements}    % A 3.3 

Digit ::=\\
\x 0 $\mid$ 1 $\mid$ 2 $\mid$ 3 $\mid$ 4 $\mid$ 5 $\mid$ 6 $\mid$ 7 $\mid$ 8 $\mid$ 9\\

Letter ::= \\
A $\mid$ B $\mid$ C $\mid$ ... $\mid$ Z $\mid$ a $\mid$ b $\mid$ c $\mid$ ... $\mid$ z\\

Identifier ::=\\
Letter [ Letter $\mid$ Digit $\mid$ \_ ] $^{...}$\\

\begin{tabbing}
\x $\mid$ \= BitStringConstant \= $\mid$ \= \kill
Constant ::= \> \> \> \\
          \> Integer           \> $\mid$ \> FloatingPointNumber\\
\x $\mid$ \> BitStringConstant \> $\mid$ \> CharacterStringConstant\\
\x $\mid$ \> TimeConstant      \> $\mid$ \> DurationConstant\\
\x $\mid$ \> {\bf NIL}         \> \> 
\end{tabbing}

Integer ::=\\
\x IntegerWithoutPrecision [ ( Precision ) ]\\

IntegerWithoutPrecision ::=\\
\x Digit $^{...}$ $\mid$ \{ 0 $\mid$ 1 \} $^{...}$ {\bf B}\\

Precision ::=\\
\x IntegerWithoutPrecision\\

FloatingPointNumber ::=\\
\x FloatingPointNumberWithoutPrecision [ ( Precision ) ]\\

FloatingPointNumberWithoutPrecision ::=\\
\x \{ Digit $^{...}$ . [ Digit $^{...}$ ] $\mid$ . Digit $^{...}$ \} [ Exponent ]\\
\x $\mid$ Digit $^{...}$ Exponent\\

Exponent ::=\\
E [ + $\mid$ - ] Digit $^{...}$\\

BitStringConstant ::=\\
\x ' B1-Digit $^{...}$ ' \{ {\bf B} $\mid$ {\bf B}1 \} $\mid$ ' B2-Digit $^{...}$ ' {\bf B}2 $\mid$ ' B3-Digit $^{...}$ ' {\bf B}3 $\mid$ ' B4-Digit$^{...}$ ' {\bf B4}\\

B1-Digit ::= 0 $\mid$ 1\\

B2-Digit ::= 0 $\mid$ 1 $\mid$ 2 $\mid$ 3\\

B3-Digit ::= 0 $\mid$ 1 $\mid$ 2 $\mid$ 3 $\mid$ 4 $\mid$ 5 $\mid$ 6 $\mid$ 7\\

B4-Digit ::= 0 $\mid$ 1 $\mid$ 2 $\mid$ 3 $\mid$ 4 $\mid$ 5 $\mid$ 6 $\mid$ 7 $\mid$ 8 $\mid$ 9 $\mid$ A $\mid$ B $\mid$ C $\mid$ D $\mid$ E $\mid$ F\\

CharacterStringConstant ::=\\
\x ' \{ CharacterBesidesApostrophe $\mid$ '' $\mid$ ControlCharacterSequence \} $^{...}$ '\\

CharacterBesidesApostrophe ::=\\
\x Digit $\mid$ Letter $\mid$ \x $\mid$ \_ $\mid$ + $\mid$ - $\mid$ $^*$ $\mid$ / $\mid$ $\backslash$ $\mid$ ( $\mid$ ) $\mid$ {\bf [} $\mid$ {\bf ]} $\mid$ : $\mid$ . $\mid$ ; $\mid$ , $\mid$ = $\mid$ $<$ $\mid$ $>$ $\mid$ !\\
\x $\mid$ $/^*$ more printable characters of the machine character set $*/$ \\

ControlCharacterSequence ::= \\
\x '$\backslash$ \{ B4-Digit B4-Digit \} $^{...}$ $\backslash$'\\

TimeConstant ::=\\
\x Digit $^{...}$ : Digit $^{...}$ : Digit $^{...}$ [ . Digit $^{...}$ ] \\

DurationConstant ::=\\
\x Hours [ Minutes ] [ Seconds ]\\
\x $\mid$ Minutes [ Seconds ]\\
\x $\mid$ Seconds\\

Hours ::=\\
\x IntegerWithoutPrecision {\bf HRS}\\

Minutes ::=\\
\x IntegerWithoutPrecision {\bf MIN}\\

Seconds ::=\\
\x \{ IntegerWithoutPrecision $\mid$ FloatingPointNumberWithoutPrecision \} {\bf SEC}

ConstantExpression ::=\\
\{ + $\mid$ - \}  FloatingPointNumber\\
\x $\mid$ \{ + $\mid$ - \} DurationConstant\\
\x $\mid$ Constant-FIXED-Expression\\

Constant-FIXED-Expression ::=\\
\x Term [ \{ + $\mid$ - \} Term ] $^{...}$\\
        
Term ::= \\
\x Factor [ \{ $^*$ $\mid$ // $\mid$ {\bf REM} \} Factor ] $^{...}$\\

Factor ::= \\
\x [ + $\mid$ - ] \\
\x \{ Integer\\
\x \x $\mid$ ( Constant-FIXED-Expression )\\
\x \x $\mid$ {\bf TOFIXED} \{ CharacterStringConstant$\S $OfLength1 $\mid$ BitStringConstant \}\\
\x \x $\mid$ Identifier$\S $Named-FIXED-Constant\\
\x \} \\
\x [ {\bf FIT} Constant-FIXED-Expression ]

\subsection{Problem Part}   % A 3.4

ProblemPart ::=\\
\x {\bf PROBLEM}; [\{ Declaration $\mid$ Specification $\mid$ Identification \} $^{...}$ ]\\

\subsubsection{Declaration}    % A 3.4.1

Declaration ::=\\
\x LengthDefinition \\
\x $\mid$ TypeDefinition\\
\x $\mid$ VariableDeclaration\\
\x $\mid$ FormatDeclaration\\
\x $\mid$ ProcedureDeclaration\\
\x $\mid$ TaskDeclaration\\
\x $\mid$ OperatorDefinition\\
\x $\mid$ PredenceDefinition\\

LengthDefinition ::=\\
\x {\bf LENGTH} \{ {\bf FIXED $\mid$ FLOAT $\mid$ BIT $\mid$ CHARACTER $\mid$ CHAR} \} ( Precision ) ;\\

TypeDefinition ::=\\
\x {\bf TYPE} Identifier$\S $ForType \{ SimpleType $\mid$ TypeStructure \} ;\\

VariableDeclaration ::=\\
\x \{ {\bf DECLARE $\mid$ DCL} \} DeclareSentence [ , DeclareSentence ] $^{...}$ ;\\
% wie ist "Satz" hier gemeint ???

DeclareSentence ::=\\
\x OneIdentifierOrList [ DimensionAttribute ]\\
\x \{ ProblemDataAttribute $\mid$ SemaAttribute $\mid$ BoltAttribute $\mid$ DationAttribute \}\\ 

OneIdentifierOrList ::= \\
\x Identifier $\mid$ ( Identifier [ , Identifier ] $^{...}$ ) \\

DimensionAttribute ::=\\
\x ( DimensionBoundaries [ , DimensionBoundaries ] $^{...}$ )\\

DimensionBoundaries ::=\\
\x [ Constant-FIXED-Expression$\S $ForLowerBoundary : ]\\
\x Constant-FIXED-Expression$\S $ForUpperBoundary\\
        
ProblemDataAttribute ::=\\
\x [ {\bf INV} ] \{ SimpleType $\mid$ StructuredType $\mid$ TypeReference \}\\
\x [ GlobalAttribute ] [ InitialisationAttribute ]\\

SimpleType ::=\\
\x \{ {\bf FIXED $\mid$ FLOAT $\mid$ BIT $\mid$ CHAR $\mid$ CHARACTER} \}\\
\x \x [ ( Constant-FIXED-Expression$\S $PrecisionResp.Length ) ]\\
\x $\mid$ {\bf CLOCK}\\
\x $\mid$ \{ {\bf DUR $\mid$ DURATION} \}\\

StructuredType ::=\\
\x TypeStructure $\mid$ Identifier$\S $ForNewDefinedType\\

TypeStructure ::=\\
\x {\bf STRUCT [} StructureComponent [ , StructureComponent ] $^{...}$ {\bf ]} \\

StructureComponent ::=\\
\x OneIdentifierOrList$\S $ForStructureComponent [ DimensionAttribute ]\\
\x TypeAttributeInStructuremComponent\\

TypeAttributeInStructureComponent ::=\\
\x [ {\bf INV} ] \{ SimpleType $\mid$ StructuredType $\mid$ TypeReference \}\\

TypeReference ::=\\
\x {\bf REF} \\
\x \{ [ VirtualDimensionList ] [ {\bf INV} ] \{ SimpleType $\mid$ StructuredType \}\\
\x \x $\mid$ [ VirtualDimensionList ] \{ TypeDation $\mid$ {\bf SEMA $\mid$ BOLT} \}\\
\x \x $\mid$ TypeProcedure $\mid$ {\bf TASK $\mid$ INTERRUPT $\mid$ IRPT $\mid$ SIGNAL}\\
\x \x $\mid$ Type-VOID $\mid$ {\bf CHAR}( )\\
\x \}\\

VirtualDimensionList ::=\\
\x ( [ , $^{...}$ ] )\\

Type-VOID ::=\\
\x {\bf STRUCT [ ]} \x $/^*$ only allowed in combination with REF $*/$\\

SemaAttribute ::=\\
\x {\bf SEMA} [ GlobalAttribute ]\\
\x [ {\bf PRESET} ( Constant-FIXED-Expression [ , Constant-FIXED-Expression ] $^{...}$ ) ]\\

BoltAttribute ::=\\
\x {\bf BOLT} [ GlobalAttribute ]\\

GlobalAttribute ::=\\
\x {\bf GLOBAL} [ ( Indicator$\S $Module ) ]\\

InitialisationAttribute ::=\\
\x \{ {\bf INITIAL $\mid$ INIT} \} ( InitElement [ , InitElement ] $^{...}$ )\\

InitElement ::=\\
\x Constant\\
\x $\mid$ Identifier$\S $NamedConstant\\
\x $\mid$ ConstantExpression\\

DationAttribute ::=\\
\x TypeDation\\
\x [ GlobalAttribute ]\\
\x {\bf CREATED} ( Indicator$\S $UserNameForSytemDation )\\

TypeDation ::=\\
\x {\bf DATION} SourceSinkAttribute  ClassAttribute\\
\x [ Topology ] [ AccessAttribute ]\\

SourceSinkAttribute ::=\\
\x {\bf IN $\mid$ OUT $\mid$ INOUT}\\

\begin{removed}
ClassAttribute ::= \\
\x {\bf ALPHIC $\mid$ BASIC} $\mid$ TypeOfTransmissionData\\
\end{removed}
\begin{added}
ClassAttribute ::= \\
\x [ {\bf SYSTEM} ]                     /* system dation */\\
\x \x {\bf ALPHIC} $\mid$                  /* PUT/GET */ \\ 
\x \x {\bf BASIC}  TypeOfTransmissionData $\mid$  /* TAKE/SEND */\\
\x \x  TypeOfTransmissionData               /* READ/WRITE */ \\
\end{added}

TypeOfTransmissionData ::=\\
\x {\bf ALL} $\mid$ SimpleType $\mid$ Indicator$\S $ForRedeclaredType $\mid$ TypeStructure\\
\x $/^*$ A Structure as transfer type may not contain any reference variable $*/$\\

Topology ::=\\
\x {\bf DIM} ( \{ $^*$ $\mid$ Constant-FIXED-Expression \}\\
\x \x [ , \{ $^*$ $\mid$ Constant-FIXED-Expression \}\\
\x \x \x [ , \{ $^*$ $\mid$ Constant-FIXED-Expression \} ] ] ) [ {\bf TFU} [ {\bf MAX} ] ]\\
\x $\mid$ {\bf DIM} ( [ , [ , ] ] ) $/^*$ Virtual dimension declaration only permitted for SPC $*/$\\

AccessAttribute ::=\\
\x \{ {\bf DIRECT $\mid$ FORWARD $\mid$ FORBACK} \}\\
\x [ {\bf NOCYCL $\mid$ CYCLIC} ]\\
\x [ {\bf STREAM $\mid$ NOSTREAM} ]\\

FormatDeclaration ::= \\
\x Identifier : {\bf FORMAT} ( FormatOrPosition [ , FormatOrPosition ] $^{...}$ ) ;\\

ProcedureDeclaration ::=\\
\x Identifier : \{ {\bf PROC $\mid$ PROCEDURE} \} [ ListOfFormalParameters ] \\
\x [ ResultAttribute ] [ GlobalAttribute ] ;\\

\x \x ProcedureBody\\

\x {\bf END};\\

ProcedureBody ::=\\
\x [\{ Declaration $\mid$ Identification \} $^{...}$ ] [ Statement $^{...}$ ] \\

ListOfFormalParameters ::=\\
\x ( FormalParameter [ , FormalParameter ] $^{...}$ )\\
        
FormalParameter ::=\\
\x OneIdentifierOrList [ VirtualDimensionList ]\\
\x \x ParameterType [ {\bf IDENT $\mid$ IDENTICAL} ]\\

ParameterType ::=\\
\x [ {\bf INV} ] \{ SimpleType $\mid$ StructuredType $\mid$ TypeReference \} $\mid$\\   
\x \x TypeRealTimeObject $\mid$ TypeDation\\

TypeRealTimeObject ::=\\   
\x {\bf SEMA $\mid$ BOLT} $\mid$ \{ {\bf INTERRUPT $\mid$ IRPT} \} $\mid$ {\bf SIGNAL}\\   

ResultAttribute ::=\\
\x {\bf RETURNS} ( ResultType )\\

ResultType ::=\\
\x SimpleType $\mid$ StructuredType $\mid$ TypeReference\\

TaskDeclaration ::=\\
\x Identifier : {\bf TASK} [ PriorityAttribute ] [ {\bf MAIN} ]\\
\x [ GlobalAttribute ]  ;\\

\x \x TaskBody\\

\x {\bf END} ;\\

TaskBody ::=\\
\x [\{ Declaration $\mid$ Identification \}$^{...}$] [Statement$^{...}$]
        
PriorityAttribute ::=\\
\x \{ {\bf PRIORITY $\mid$ PRIO} \} Constant-FIXED-Expression$\S $GreaterZero\\

OperatorDefinition ::= \\
\x {\bf OPERATOR} OpName ( OpParameter [ , OpParameter ] ) ResultAttribute ;\\

\x \x ProcedureBody\\

\x {\bf END} ; \\

OpName ::=\\
\x Identifier $\mid + \mid - \mid ^* \mid / \mid // \mid ^{**} \mid == \mid /= \mid <= \mid >= \mid < \mid > \mid <> \mid ><$\\

OpParameter ::=\\
\x Identifier [ VirtualDimensionList ] ParameterType [ {\bf IDENT $\mid$ IDENTICAL} ] \\

PrecedenceDefinition ::= \\
\x {\bf PRECEDENCE} OpName ( \{ 1 $\mid$ 2 $\mid$ 3 $\mid$ 4 $\mid$ 5 $\mid$ 6 $\mid$ 7 \} ) ;

\subsection{Specification and Identification}    % A 3.4.2

Specification ::=\\
\x \{ {\bf SPC $\mid$ SPECIFY} \} SpecificationDefinition [ , SpecificationDefinition ] $^{...}$ ;\\

SpecificationDefinition ::=\\
\x OneIdentifierOrList\\
\x \{ SpecificationAttribute $\mid$ ProcedureUsageAttribute $\mid$ TaskUsageAttribute \}\\

SpecificationAttribute ::=\\
\x [ VirtualDimensionList ] \\
\x \{ [ {\bf INV} ] \{ SimpleType $\mid$ StructuredType $\mid$ TypeReference \} \\
\x \x $\mid$ {\bf SEMA $\mid$ BOLT $\mid$ INTERRUPT $\mid$ IRPT $\mid$ SIGNAL} $\mid$ TypeDation\\
\x \}\\
\x [ GlobalAttribute ]\\

ProcedureUsageAttribute ::=\\
\x \{ {\bf ENTRY} $\mid$ [ : ] {\bf PROC} \} [ ParameterListFor-SPC ] [ ResultAttribute ] \\
\x \x GlobalAttribute\\

ParameterListFor-SPC ::=\\
\x ( FormalParameterFor-SPC [ , FormalParameterFor-SPC ] $^{...}$ )\\
        
FormalParameterFor-SPC ::=\\
\x [ Identifier$\S $OnlyForDocumentation ] [ VirtualDimensionList ]\\
\x ParameterType [ {\bf IDENTICAL $\mid$ IDENT} ]\\

TypeProcedure ::=\\
\x {\bf PROC} [ ParameterListFor-SPC ] [ ResultAttribute ] $/^*$ for REF PROC $*/$\\

TaskUsageAttribute ::=\\
\x {\bf TASK} GlobalAttribute\\

Identification ::=\\
\x \{ {\bf SPC $\mid$ SPECIFY}\} Identifier [ {\bf INV} ] Type IdentificationAttribute ;\\

IdentificationAttribute ::= \\
\x {\bf IDENT} ( Name$\S $Object )\\

\subsection{Expressions}    % A 3.4.3

Expression ::=\\
\x [ MonadicOperator ] Operand [ DyadicOperator   Expression ] $^{...}$\\

MonadicOperator ::=\\
\x + $\mid$ - $\mid$ Identifier$\S $MonadicOperator\\

DyadicOperator ::=\\
\x $ + \mid - \mid ^* \mid / \mid // \mid ^{**} \mid < \mid > \mid <= \mid >= \mid == \mid /= \mid >< \mid <> \mid$\\
\x Identifier$\S $DyadicOperator\\

Operand ::= \\
\x Constant $\mid$ Name $\mid$ FunctionCall $\mid$ ConditionalExpression\\
\x $\mid$ Dereferentiation $\mid$ StringSelection $\mid$ ( Expression ) $\mid$ ( Assignment ) \\
\x $\mid$ {\bf PRIO} [ ( Name$\S $Task ) ] $\mid$ {\bf TASK} [ ( Name$\S $Task ) ] $\mid$ {\bf TRY} Name$\S $Sema\\

Name ::=\\
\x Identifier [ ( Index [ , Index ] $^{...}$ ) ] [ . Name ]\\

Index ::=\\
\x Expression$\S $WithIntegerAsValue\\

FunctionCall ::=\\
\x Identifier$\S $FunctionProcedure [ ListOfActualParameters ]\\

ListOfActualParameters ::= \\
\x ( Expression [ , Expression ] $^{...}$ )\\

ConditionalExpression ::=\\
\x {\bf IF} Expression$\S $OfType-BIT(1) {\bf THEN} Expression {\bf ELSE} Expression {\bf FIN}\\

Dereferentiation ::=\\
\x {\bf CONT} \{ Name$\S $Reference $\mid$ FunctionCall \}\\

StringSelection ::=\\
\x Name$\S $String . \{ {\bf BIT $\mid$ CHAR $\mid$ CHARACTER} \}\\ 
\x ( \{ Constant-FIXED-Expression [ : Constant-FIXED-Expression ]\\
\x \x $\mid$ Expression [ : Expression + Constant-FIXED-Expression ]\\
\x \x $\mid$ Expression [ : Expression ] \} )\\

\subsection{Statements}    % A 3.4.4

Statement ::=\\
\x [ Identifier$\S $Label : ] $^{...}$ UnlabelledStatement\\

UnlabelledStatement ::=\\
\x EmptyStatement $\mid$ Assignment $\mid$ Block $\mid$ SequentialControlStatement\\
\x $\mid$ RealTimeStatement $\mid$ ConvertStatement $\mid$ I/O-Statement\\

EmptyStatement ::=\\
\x ;\\

Assignment ::=\\
\x \{ \{ Name$\S $Variable $\mid$ Dereferentiation $\mid$ StringSelection $\mid$ 
Name$\S $Structure \}\\   
\x \{ := $\mid$ = \} \} $^{...}$ Expression ;\\

Block ::= \\
\x {\bf BEGIN}\\
\x \x [\{ Declaration $\mid$ Identification \}$^{...}$ ]\\ 
\x \x [ Statement $^{...}$ ] \\
\x {\bf END} [ Identifier$\S $Block ] ;\\

SequentialControlStatement ::=\\
\x IfStatement $\mid$ CaseStatement $\mid$ LoopStatement $\mid$ ExitStatement\\
\x $\mid$ ProcedureCall $\mid$ ReturnStatement $\mid$ GoToStatement\\

IfStatement ::=\\
\x {\bf IF} Expression$\S $OfType-BIT(1)\\
\x \x {\bf THEN} [ Statement $^{...}$ ]\\ 
\x \x [ {\bf ELSE} [ Statement $^{...}$ ] ]\\
\x {\bf FIN} ;\\

CaseStatement ::=\\
\x StatementSelection1 $\mid$ StatementSelection2\\

CaseStatement1 ::=\\
\x {\bf CASE} Expression$\S $WithIntegerAsValue\\
\x \x \{ {\bf ALT} [ Statement $^{...}$ ] \} $^{...}$\\
\x \x [ {\bf OUT} [ Statement $^{...}$ ] ]\\
\x {\bf FIN} ;\\

CaseStatement2 ::=\\
\x {\bf CASE} CaseIndex\\
\x \x \{ {\bf ALT} ( CaseList ) [ Statement $^{...}$ ] \} $^{...}$\\
\x \x [ {\bf OUT} [ Statement $^{...}$ ] ]\\
\x {\bf FIN} ;\\

CaseIndex ::=\\
\x Expression$\S $WithValueOfType-FIXED-Or-CHAR(1)\\

CaseList ::=\\
\x IndexSection [ , IndexSection ] $^{...}$\\

IndexSection::=\\
\x Constant-FIXED-Expression [ : Constant-FIXED-Expression ]\\
\x $\mid$ CharacterStringConstant$\S $OfLength1 [ : CharacterStringConstant$\S $OfLength1 ]\\

LoopStatement ::=\\
\x [ {\bf FOR} Indicator$\S $ControlVariable ]\\
\x [ {\bf FROM} Expression$\S $InitialValue ]\\
\x [ {\bf BY} Expression$\S $StepLength ]\\
\x [ {\bf TO} Expression$\S $EndValue ]\\
\x [ {\bf WHILE} Expression$\S $Condition ]\\
\x {\bf REPEAT}\\
\x \x [\{ Declaration $\mid$ Identification \}$^{...}$ ]\\ 
\x \x [ Statement $^{...}$ ] \\
\x {\bf END} [ Identifier$\S $Loop ] ;\\
        
ExitStatement ::=\\
\x {\bf EXIT} [ Identifier$\S $BlockOrLoop ] ;\\

ProcedureCall ::= \\
\x [ {\bf CALL} ] Name$\S $SubprogramProcedure [ ListOfActualParameter ] ;\\

ReturnStatement ::= \\
\x {\bf RETURN} [ ( Expression ) ] ;\\

GoToStatement ::= \\
\x {\bf GOTO} Identifier$\S $Label ; \\

RealTimeStatement ::=\\
\x TaskControlStatement $\mid$ TaskCoordination\\
\x $\mid$ InterruptStatement $\mid$ SignalStatement\\

TaskControlStatement ::=\\
\x TaskStarting $\mid$ TaskTerminating\\             
\x $\mid$ TaskSuspending $\mid$ TaskContinuing\\   
\x $\mid$ TaskResuming $\mid$ TaskPreventing\\

TaskStarting ::=\\
\x [ StartCondition ] {\bf ACTIVATE} Name$\S $Task [ PriorityExpression ] ;\\

PriorityExpression ::=\\
\x \{ {\bf PRIORITY $\mid$ PRIO} \} Expression$\S $PositiveInteger\\

StartCondition ::=\\
\x {\bf AT} Expression$\S $Time [ Frequency ]\\
\x $\mid$ {\bf AFTER} Expression$\S $Duration [ Frequency ]\\
\x $\mid$ {\bf WHEN} Name$\S $Interrupt [ {\bf AFTER} Expression$\S $Duration ] [ Frequency ] \\
\x $\mid$ Frequency\\

Frequency ::=\\
\x {\bf ALL} Expression$\S $Duration\\
\x [ \{ {\bf UNTIL} Expression$\S $Time \} $\mid$ \{ {\bf DURING} Expression$\S $Duration \} ]\\

TaskTerminating ::=\\
\x {\bf TERMINATE} [ Name$\S $Task ] ; \\

TaskSuspending ::=\\
\x {\bf SUSPEND} [ Name$\S $Task ] ;\\

TaskContinuing ::=\\
\x [ {\bf AT} Expression$\S $Time $\mid$ {\bf AFTER} Expression$\S $Duration $\mid$ {\bf WHEN} Name$\S $Interrupt ]\\
\x {\bf CONTINUE} [ Name$\S $Task ] [ PriorityAttribute ] ;\\

TaskResuming ::=\\
\x \{ {\bf AT} Expression$\S $Time $\mid$ {\bf AFTER} Expression$\S $Duration $\mid$ {\bf WHEN} Name$\S $Interrupt \}\\
\x {\bf RESUME;}\\        

TaskPreventing ::=\\
\x {\bf PREVENT} [ Name$\S $Task ] ;\\

TaskCoordiniationStatement ::=\\
\x \{ {\bf REQUEST $\mid$ RELEASE}\} Name$\S $Sema [ , Name$\S $Sema ] $^{...}$ ;\\
\x $\mid$ \{ {\bf RESERVE $\mid$ FREE $\mid$ ENTER $\mid$ LEAVE} \} Name$\S $Bolt [ , Name$\S $Bolt ] $^{...}$ ;\\


InterruptStatement ::=\\
\x \{ {\bf ENABLE $\mid$ DISABLE $\mid$ TRIGGER} \} Name$\S $Interrupt ;\\

\begin{removed}
SchedulingSignalReaction ::=\\
\x {\bf ON} Name$\S $Signal \{ [ {\bf RST} ( Name$\S $ErrorVariable-FIXED ) ] :\\
\x \x SignalReaction $\mid$ {\bf RST} ( Name$\S $ErrorVariable-FIXED ) \};\\

SignalReaction::= UnlabeledStatement\\

InduceStatement ::=\\
\x {\bf INDUCE} Name$\S $Signal [ {\bf RST} ( Expression$\S $ErrorNumber-FIXED ) ] ;\\
\end{removed}
\begin{added}
SchedulingSignalReaction ::=\\
\x {\bf ON} Name$\S $Signal [ {\bf RST} ( Name$\S $ErrorVariable-FIXED ) ] :\\
\x \x SignalReaction ;

SignalFinalStatement ::= \\
\x ReturnStatement $\mid$ \\
\x GoToStatement $\mid$ \\
\x InduceStatement $\mid$ \\
\x {\bf TERMINATE} ;

SignalReaction ::=\\
\x SignalFinalStatement $\mid$ \\
\x Block$\S $terminatedWithSignalFinalStatement ;

InduceStatement ::=\\
\x {\bf INDUCE} [ Name$\S $Signal [ {\bf RST} ( Expression$\S $ErrorNumber-FIXED ) ] ] ;\\
\end{added}

ConvertStatement ::=\\
\x ConvertToStatement $\mid$ ConvertFromStatement\\

ConvertToStatement ::= \\
\x {\bf CONVERT} Expression [ , Expression ] $^{...}$ {\bf TO} Name$\S $CharacterStringVariable\\
\x [ {\bf BY} FormatOrPositionConvert [ , FormatOrPositionConvert ] $^{...}$ ] ;\\

ConvertFromStatement ::=\\
\x {\bf CONVERT} Name$\S $Variable [ , Name$\S $Variable ] $^{...}$ {\bf FROM} Expression$\S $CharacterString\\
\x [ {\bf BY} FormatOrPositionConvert [ , FormatOrPositionConvert ] $^{...}$ ] ;\\

FormatOrPositionConvert ::= \\
\x [ Factor ] \{ Format $\mid$ PositionConvert \}\\
\x $\mid$ Factor ( FormatOrPositionConvert [ , FormatOrPositionConvert ] $^{...}$ )\\

PositionConvert ::= \\
\x {\bf RST} ( Name$\S $ErrorVariable-FIXED )\\
\x $\mid$ {\bf X} [ ( Expression ) ]\\
\x $\mid$ \{ {\bf POS $\mid$ ADV} \} ( Expression )\\
\x $\mid$ {\bf SOP} ( Name$\S $PositionVariable-FIXED )\\

I/O-Statement ::=\\
\x OpenStatement $\mid$ CloseStatement\\
\x $\mid$ PutStatement $\mid$ GetStatement\\
\x $\mid$ WriteStatement $\mid$ ReadStatement\\
\x $\mid$ SendStatement $\mid$ TakeStatement\\
         
OpenStatement ::=\\
\x {\bf OPEN} Name$\S $Dation [ {\bf BY} OpenParameter [ , OpenParameter ] $^{...}$ ] ;\\

OpenParameter ::=\\
\x {\bf RST} ( Name$\S $ErrorVariable-FIXED )\\
\x $\mid$ {\bf IDF} ( \{ Name$\S $CharacterStringVariable $\mid$ CharacterStringConstant \} )\\
\x $\mid$ \{ {\bf OLD $\mid$ NEW $\mid$ ANY} \}\\
\x $\mid$ \{ {\bf CAN $\mid$ PRM} \}\\

CloseStatement ::=\\ 
\x {\bf CLOSE} Name$\S $Dation [ {\bf BY} CloseParameter [ , CloseParameter ] $^{...}$ ] ;\\

CloseParameter ::=\\
\x {\bf RST} ( Name$\S $ErrorVariable-FIXED )\\
\x $\mid$ \{ {\bf CAN $\mid$ PRM} \}\\

PutStatement ::=\\
\x {\bf PUT} [ \{ Expression $\mid$ Slice \} [ , \{ Expression $\mid$ Slice \} ] $^{...}$ ]\\
\x {\bf TO} Name$\S $Dation [ {\bf BY} FormatOrPosition [ , FormatOrPosition ] $^{...}$ ] ;\\

GetStatement ::=\\
\x {\bf GET} [ \{ Name $\mid$ Slice \} [ , \{ Name $\mid$ Slice \} ] $^{...}$ ]\\
\x {\bf FROM} Name$\S $Dation [ {\bf BY} FormatOrPosition [ , FormatOrPosition ] $^{...}$ ] ;\\

WriteStatement ::=\\
\x {\bf WRITE} [ \{ Expression $\mid$ Slice \} [ , \{ Expression $\mid$ Slice \} ] $^{...}$ ]\\
\x {\bf TO} Name$\S $Dation [ {\bf BY} Position [ , Position ] $^{...}$ ] ; \\
        
ReadStatement ::=\\
\x {\bf READ} [ \{ Name $\mid$ Slice \} [ , \{ Name $\mid$ Slice \} ] $^{...}$ ]\\
\x {\bf FROM} Name$\S $Dation [ {\bf BY} Position [ , Position ] $^{...}$ ] ;\\
        
SendStatement ::=\\
\x {\bf SEND} [ Expression ] {\bf TO} Name$\S $Dation\\
\x [ {\bf BY} RST-S-CTRL-Format [ , RST-S-CTRL-Format ] $^{...}$ ] ;\\

TakeStatement ::=\\
\x {\bf TAKE} [ Name ] {\bf FROM} Name$\S $Dation\\
\x [ {\bf BY} RST-S-CTRL-Format [ , RST-S-CTRL-Format ] $^{...}$ ] ;\\

RST-S-CTRL-Format ::=\\
\x {\bf RST} ( Name$\S $ErrorVariable-FIXED )\\
\x $\mid$ {\bf S} ( Name$\S $Variable-FIXED )\\
\x $\mid$ {\bf CONTROL} ( Expression [ , Expression [ , Expression ] ] )\\

Slice ::=\\
\x Name$\S $Array ( [ Index , ] $^{...}$ Index : Index )\\
\x $/^*$ Instead of the last array-index an index-slice is given to address 
the respective one-dimensional array-slice which is processed by the I/O 
in bottom-up order. $*/$\\

FormatOrPosition ::=\\
\x [ Factor ] \{ Format $\mid$ Position \}\\
\x $\mid$ Factor ( FormatOrPosition [ , FormatOrPosition ] $^{...}$ )\\
        
Factor ::=\\
\x ( Expression$\S $IntegerGreaterZero ) $\mid$ IntegerWithoutPrecision$\S $GreaterZero\\

Format ::=\\
\x \{ {\bf F $\mid$ E}\} ( Expression [ , Expression [ , Expression ] ] ) \\
\x $\mid$ \{ {\bf B $\mid$ B1 $\mid$ B2 $\mid$ B3 $\mid$ B4 $\mid$ A} \} [ ( Expression ) ]\\
\x $\mid$ \{ {\bf T $\mid$ D} \} ( Expression [ , Expression ] )\\
\x $\mid$ {\bf LIST}\\
\x $\mid$ {\bf R} ( Identifier$\S $Format )\\
\x $\mid$ {\bf S} ( Name$\S $LengthVariable-FIXED )\\

Position ::=\\
\x {\bf RST} ( Name$\S $ErrorVariable-FIXED )\\
\x $\mid$ \{ {\bf X $\mid$ SKIP $\mid$ PAGE} \} [ ( Expression ) ]\\
\x $\mid$ \{ {\bf POS $\mid$ ADV} \} ( Expression [ , Expression [ , Expression ] ] )\\
\x $\mid$ \{ {\bf COL $\mid$ LINE} \} ( Expression )\\
\x $\mid$ {\bf SOP} ( Name [ , Name [ , Name ] ]  $/^*$ PositionVariables-FIXED $^*/$ )\\

\twocolumn[\section{List of Keywords with Shortforms}   % A 4

The denotation behind the keyword refers to the paragraph where it
is introduced.\\]

{
{\bf ACTIVATE} 9.2.2\\
{\bf AFTER} 9.2.1\\
{\bf ALL} 9.2.1\\
{\bf ALPHIC} \ref{sec_dation_problem_part}\\
{\bf ALT} 7.2\\
{\bf AT} 9.2.1\\

{\bf BASIC} \ref{sec_dation_problem_part}\\
{\bf BEGIN} 4.4 \\
{\bf BIT} 5.4\\
{\bf BOLT} 9.3.2\\
{\bf BY} 7.3, \ref{sec_open_close}\\

{\bf CALL} 8.2\\
{\bf CASE} 7.2\\
{\bf CHARACTER}, {\bf CHAR} 5.5\\
{\bf CLOCK} 5.7\\
{\bf CLOSE} \ref{sec_open_close}\\
{\bf CONT} 5.9\\
{\bf CONTINUE} 9.2.5\\
{\bf CONTROL} \ref{sec_dation_problem_part}\\
{\bf CONVERT} \ref{sec_dation_problem_part}\\
{\bf CREATED} \ref{sec_dation_problem_part}\\
{\bf CYCLIC} \ref{sec_dation_problem_part}\\
 
{\bf DATION} \ref{sec_dation_problem_part}\\
{\bf DECLARE}, {\bf DCL} 4.1\\
{\bf DIM} \ref{sec_dation_problem_part}\\
{\bf DIRECT} \ref{sec_dation_problem_part}\\
{\bf DISABLE} 9.4.2\\
{\bf DURATION}, {\bf DUR} 5.8\\
{\bf DURING} 9.2.1\\

{\bf ELSE} 7.1\\
{\bf ENABLE} 9.4.2\\
{\bf END} 4.4, 8.1, 9.1\\
{\bf ENTER} 9.3.2\\
{\bf ENTRY} 8.1\\
{\bf EXIT} 7.5\\

{\bf FIN} 7.1\\
{\bf FIXED} 5.2\\
{\bf FLOAT} 5.3\\
{\bf FOR} 7.3\\
{\bf FORBACK} \ref{sec_dation_problem_part}\\
{\bf FORMAT} 10.5.8\\
{\bf FORWARD} \ref{sec_dation_problem_part}\\
{\bf FREE} 9.3.2\\
{\bf FROM} 7.3, \ref{sec_read_write}\\
 
{\bf GET} \ref{sec_get_put}\\
{\bf GLOBAL} 4.1\\
{\bf GOTO} 7.4\\
 
{\bf HRS} 5.8\\
 
{\bf IDENTICAL}, {\bf IDENT} 4.1, 8.1\\
{\bf IF} 7.1\\                           
{\bf IN} \ref{sec_dation_problem_part}\\
{\bf INDUCE} 11\\
{\bf INITIAL}, {\bf INIT} 5.14\\
{\bf INOUT} \ref{sec_dation_problem_part}\\
{\bf INTERRUPT}, {\bf IRPT} 9.4.1\\
{\bf INV} 5.15\\
 
{\bf LEAVE} 9.3.2\\
{\bf LENGTH} 5.6\\
 
{\bf MAIN} 9.1\\
{\bf MAX} \ref{sec_dation_problem_part}\\
{\bf MIN} 5.8\\
{\bf MODEND} 4.1\\
{\bf MODULE} 4.1\\
 
{\bf NIL} 5.9\\
{\bf NOCYCL} \ref{sec_dation_problem_part}\\
{\bf NOSTREAM} \ref{sec_dation_problem_part}\\

{\bf ON} 11\\
{\bf OPEN} 10.3\\
{\bf OPERATOR} 6.2\\
{\bf OUT} 7.2, \ref{sec_dation_problem_part}\\
 
{\bf PRECEDENCE} 7.2\\
{\bf PRESET} 9.3.1\\
{\bf PREVENT} 9.2.7\\
{\bf PRIORITY}, {\bf PRIO} 9.1\\
{\bf PROBLEM} 4.3\\
{\bf PROCEDURE}, {\bf PROC} 8.1\\
{\bf PUT} \ref{sec_get_put}\\

{\bf READ} \ref{sec_dation_read_write}\\
{\bf REF} 5.9\\
{\bf RELEASE} 9.3.1\\
{\bf REPEAT} 7.3\\
{\bf REQUEST} 9.3.1\\
{\bf RESERVE} 9.3.2\\
{\bf RESUME} 9.2.6\\
{\bf RETURN} 8.2\\
{\bf RETURNS} 8.1\\
 
{\bf SEC} 5.8\\
{\bf SEMA} 9.3.1\\
{\bf SEND} \ref{sec_dation_take_send}\\
{\bf SIGNAL} 11\\
{\bf SPECIFY}, {\bf SPC} 4.1\\
{\bf STREAM} \ref{sec_dation_problem_part}\\
{\bf STRUCT} 5.11\\
{\bf SUSPEND} 9.2.4\\
{\bf SYSTEM} 4.2\\
 
{\bf TAKE} \ref{sec_dation_take_send}\\
{\bf TASK} 9.1\\
{\bf TERMINATE} 9.2.3\\
{\bf TFU} \ref{sec_dation_problem_part}\\
{\bf THEN} 7.1\\
{\bf TO} 7.3, \ref{sec_dation_read_write}\\
{\bf TRIGGER} 9.4.2\\
{\bf TYPE} 5.12\\
 
{\bf UNTIL} 9.2.1\\
 
{\bf WHEN} 9.2.1\\
{\bf WHILE} 7.3\\
{\bf WRITE} \ref{sec_dation_read_write}\\
}
\onecolumn

\twocolumn[\section{Other Word Symbols in PEARL}    % A 5

The denotation behind the word symbol refers to the paragraph where it
is introduced.\\]

{
{\bf A} \ref{sec_dation_a_format}\\
{\bf ABS} 6.1.1\\
{\bf ADV} \ref{sec_dation_read_write}\\
{\bf AND} 6.1.2\\
{\bf ANY} \ref{sec_dation_open_close}\\
{\bf ATAN} 6.1.1\\

{\bf B} \ref{sec_dation_b_format}\\
{\bf B1} \ref{sec_dation_b_format}\\
{\bf B2} \ref{sec_dation_b_format}\\
{\bf B3} \ref{sec_dation_b_format}\\
{\bf B4} \ref{sec_dation_b_format}\\

{\bf CAN} \ref{sec_dation_open_close}\\
{\bf CAT} 6.1.2\\
{\bf COL} \ref{sed_dation_read_write}\\
{\bf CONT} 5.9\\
{\bf COS} 6.1.1\\
{\bf CSHIFT} 6.1.2\\
 
{\bf D} \ref{sec_dation_d_format}\\
{\bf DATE} A2.2\\
 
{\bf E} \ref{sec_dation_e_format}\\
{\bf ENTIER} 6.1.1\\
{\bf EQ} 6.1.2\\
{\bf EXOR} 6.1.2\\
{\bf EXP} 6.1.1\\
 
{\bf F} \ref{sec_dation_f_format}\\
{\bf FIT} 6.1.2\\
 
{\bf GE} 6.1.2\\
{\bf GT} 6.1.2\\
 
{\bf IDF} \ref{sec_dation_open_close}\\
{\bf IS} 5.9\\
{\bf ISNT} 5.9\\

 
{\bf LE} 6.1.2\\
{\bf LINE} \ref{sec_dation_read_write}\\
{\bf LIST} \ref{sec_dation_listformat}\\
{\bf LN} 6.1.1\\
{\bf LT} 6.1.2\\
{\bf LWB} 6.1.1, 6.1.2\\
 
{\bf NE} 6.1.2\\
{\bf NEW} \ref{sec_dation_open_close}\\
{\bf NOT} 6.1.1\\
{\bf NOW} A2.1\\
 
{\bf OLD} 10.3\\
{\bf OR} 6.1.2\\
 
{\bf PAGE} \ref{sec_dation_read_write}\\
{\bf POS} \ref{sec_dation_read_write}\\
{\bf PRM} \ref{sec_dation_open_close}\\
 
{\bf R} \ref{sec_dation_r_format}\\
{\bf REM} 6.1.2\\
{\bf ROUND} 6.1.1\\
{\bf RST} \ref{sec_dation_open_close}, \ref{sec_dation_rst} \\
 
{\bf S} \ref{sec_dation_a_format}\\
{\bf SHIFT} 6.1\\
{\bf SIGN} 6.1.1\\
{\bf SIN} 6.1.1\\
{\bf SIZEOF} 6.1\\
{\bf SKIP} \ref{sec_dation_read_write} \\
{\bf SOP}  \ref{sec_dation_read_write}\\
{\bf SQRT} 6.1.1\\
 
{\bf T} \ref{sec_dation_t_format}\\
{\bf TAN} 6.1.1\\
{\bf TANH} 6.1.1\\
{\bf TOBIT} 6.1.1\\
{\bf TOCHAR} 6.1.1\\
{\bf TOFIXED} 6.1.1\\
{\bf TOFLOAT} 6.1.1\\
{\bf TRY} 9.3.1\\
 
{\bf UPB} 6.1.1, 6.1.2\\

{\bf X} \ref{sec_dation_read_write}
}

